<!DOCTYPE html>
<html>
	<head>
		<title>Emmet</title>
	</head>
	<body>
    <!--https://docs.emmet.io/-->
    <!--dl>p.item$*5>div^^a*2+(header>ul>li*2>a)-->
    <!--p.item$*5>div^a*2+(header>ul>li*2>a)-->
    <!--(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))-->
    <!--(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))+(p.item>div^a*2+(header>ul>li*2>a))-->
		<script type="text/javascript">
			function emmet(str) {
                const d = document, ac = 'appendChild', lc = 'lastChild', ctn = 'createTextNode', ss = 'substr', lth = 'length', rpc = 'replace', sp = 'split', g = 'groups';

                // t for text, a for attr, g for group, c for cal, l for level, e for tag
                const tokenRegex = /(?<t>{.+?})|(?<a>\[.+?\])|(?<g>\(.+?\))|(?<c>[\$\@\-\d]*\*\d+)|(?<l>[\>\+\^]+)|(?<e>[a-z1-6]+)/gi;

                let tree = d.createDocumentFragment(), currentNode = tree, curToken, preToken;
                
                console.log(str.match(tokenRegex));

                let timesArr = [];

                while((curToken = tokenRegex.exec(str)) !== null){
                    let gp = curToken[g], t = curToken[0];

                    if(gp.t){ // 文本标签
                        if(preToken && preToken[g].e){ // 上个token为标签
                            currentNode[lc][ac](d[ctn](t[ss](1, t[lth] - 2)));
                        }else{
                            currentNode[ac](d[ctn](t[ss](1, t[lth] - 2)));
                        }
                    }else if(gp.g){ // 分组
                        let gFrag = emmet(t[ss](1, t[lth] - 2));
                        currentNode[ac](gFrag);
                    }else if(gp.c){
                        let times = parseInt(gp.c[sp]('*')[1]);

                        if(str[curToken.index + curToken[0].length] == '>'){
                            timesArr.push({times: times, depth: 0});
                        }else{
                            for(let j = 1; j < times; j++){
                                currentNode[ac](currentNode[lc].cloneNode(true));
                            }
                        }
                    }else if(gp.l){ // 树层级控制
                        let levelArr = gp.l.split('');
                        for(let l = 0; l < levelArr.length; l++){
                            if(levelArr[l] == '>'){
                                for(let i = 0; i < timesArr.length; i++)timesArr[i].depth++;
                                currentNode = currentNode[lc];
                            }else if(levelArr[l]== '^'){
                                for(let i = timesArr.length - 1; i > -1; i--){
                                    if(--(timesArr[i].depth) < 1){
                                        while(--(timesArr[i].times))currentNode.parentNode.appendChild(currentNode.cloneNode(true));
                                        timesArr.splice(i, 1);
                                    }
                                }
                                currentNode = currentNode.parentNode;
                            }
                        }
                    }else if(gp.e){ // 非文本标签
                        currentNode[ac](d.createElement(t));
                    }else if(gp.a){ // 属性
                        let kvStr = t[ss](1, t[lth] - 2)[sp](/[\'\"]+ /gi);
                        for(let i = 0; i < kvStr[lth]; i++){
                            let kv = kvStr[i][sp]('=');
                            currentNode[lc].setAttribute(kv[0], kv[1][rpc](/[\"\']/gi, ''));
                        }
                    }

                    if(!gp.a)preToken = curToken; // curToken为属性时不需要更新
                }

                if(timesArr.length){
                    for(let i = timesArr.length - 1; i > -1; i--){
                        while(timesArr[i].depth-- > 1){
                            currentNode = currentNode.parentNode;
                        }
                        while(--(timesArr[i].times))currentNode.parentNode.appendChild(currentNode.cloneNode(true));
                    }
                }

                return tree;
			}
			console.log(emmet('div[title="title"]*2>span{i am span}^p+(h1>span{span in group})+div[title="title" class="class1 class2"]{wenben}*3'));//div>(header>ul>li*2>a)+footer>p$*5>div+span+span{i am span}

			//console.log(emmet('div*3>p*2>span*5'));//div>(header>ul>li*2>a)+footer>p$*5>div+span+span{i am span}
		</script>
	</body>
</html>