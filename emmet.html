<!DOCTYPE html>
<html>
	<head>
		<title>Emmet</title>
	</head>
	<body>
        emmet:<br><textarea id="emmet" cols="60" rows="10"></textarea><br>
        html:<br><textarea id="html" cols="60" rows="10"></textarea><br>
        <button onclick="emmetToHtml()">emmet to html</button>

        <!--https://docs.emmet.io/-->
		<script type="text/javascript">
			function emmet(str) {
                var doc = document, appendChild = 'appendChild', lastChild = 'lastChild', createTextNode = 'createTextNode', 
                substr = 'substr', lth = 'length', rpc = 'replace', sp = 'split', g = 'groups',
                pn = 'parentNode', cn = 'cloneNode';

                // t for text, a for attr, g for group, c for cal, l for level, e for tag
                var tokenRegex = /(?<t>{.+?})|(?<a>\[.+?\])|(?<g>\(.+\))|(?<c>[\$\@\-\d]*\*\d+)|(?<l>[\>\+\^]+)|(?<e>[a-z1-6]+)/g;

                var tree = doc.createDocumentFragment(), currentNode = tree, curToken, preToken, gFrag, gp, t, times;
                var timesArr = []; // {times: 0, depth: 0}
                var i, j, l, kvStr, kv, levelArr;

                while(curToken = tokenRegex.exec(str)){
                    gp = curToken[g];
                    t = curToken[0];

                    if(gp.t){ // 文本标签
                        if(preToken && preToken[g].e){ // 上个token为标签
                            currentNode[lastChild][appendChild](doc[createTextNode](t[substr](1, t[lth] - 2)));
                        }else{
                            currentNode[appendChild](doc[createTextNode](t[substr](1, t[lth] - 2)));
                        }
                    }else if(gp.g){ // 分组
                        gFrag = emmet(t[substr](1, t[lth] - 2));
                        currentNode[appendChild](gFrag[cn](true));
                    }else if(gp.c){
                        times = +(gp.c[sp]('*')[1]);

                        if(str[curToken.index + curToken[0][lth]] == '>'){
                            timesArr.push({t: times, d: 0});
                        }else{
                            for(j = 1; j < times; j++){
                                currentNode[appendChild](preToken && preToken[g].g ? gFrag[cn](true) : currentNode[lastChild][cn](true));
                            }
                        }
                    }else if(gp.l){ // 树层级控制
                        levelArr = gp.l[sp]('');
                        for(l = 0; l < levelArr[lth]; l++){
                            if(levelArr[l] == '>'){
                                for(i = 0; i < timesArr[lth]; i++)timesArr[i].d++;
                                if(currentNode[lastChild].nodeType != 3)currentNode = currentNode[lastChild]; // 非文本节点才进行赋值
                            }else if(levelArr[l] == '^'){
                                for(i = timesArr[lth] - 1; i > -1; i--){
                                    if(--(timesArr[i].d) < 1){
                                        while(--(timesArr[i].t))currentNode[pn][appendChild](currentNode[cn](true));
                                        timesArr.splice(i, 1);
                                    }
                                }
                                if(currentNode[pn])currentNode = currentNode[pn];
                            }
                        }
                    }else if(gp.e){ // 非文本标签
                        currentNode[appendChild](doc.createElement(t));
                    }else if(gp.a){ // 属性
                        kvStr = t[substr](1, t[lth] - 2)[sp](/[\'\"]+ /g);
                        for(i = 0; i < kvStr[lth]; i++){
                            kv = kvStr[i][sp]('=');
                            currentNode[lastChild].setAttribute(kv[0], kv[1][rpc](/[\"\']/g, ''));
                        }
                    }

                    if(!gp.a)preToken = curToken; // curToken为属性时不需要更新
                }

                if(timesArr[lth]){
                    for(i = timesArr[lth] - 1; i > -1; i--){
                        while(timesArr[i].d-- > 1){
                            currentNode = currentNode[pn];
                        }
                        while(--(timesArr[i].t))currentNode[pn][appendChild](currentNode[cn](true));
                    }
                }

                return tree;
            }
            
            let badCases = [
                '(div>dl>(dt+dd)*3)+footer>p',
                'div+{ hello guys!@#$%^&*().[]{}+(div+header>ul>li*5>a{click})*2+footer>p'
            ];

            for(let i = 0; i < badCases.length; i++){
                console.log(emmet(badCases[i]));
            }
            
            function emmetToHtml(){
                let div = document.createElement('div');
                div.append(emmet(document.querySelector('#emmet').value));
                document.querySelector('#html').value = div.innerHTML;
            }
		</script>
	</body>
</html>